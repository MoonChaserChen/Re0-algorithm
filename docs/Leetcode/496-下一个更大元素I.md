# 下一个更大元素 I
nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。

给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。

对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。

返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。

示例 1：

```
输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
```

示例 2：
```
输入：nums1 = [2,4], nums2 = [1,2,3,4].
输出：[3,-1]
```

## 解法：单调栈+哈希表
```python
def next_greater_element(nums1, nums2):
    # 依次求nums2中每个元素的右侧第一个比它大的数，组成个map。再遍历nums1从这个map中取值即可
    # 倒着遍历nums2：
    # 如果下个数比当前数num更大，则当前数肯定不会是接下来的任一数的结果，可以忽略，这个操作可以重复。比如 [1, 4, 3, 2]，遍历到4时，3和2其实都可以忽略（因为求第一个更大的数，如果能够选3和2，那么也可以选4）
    # 用一个栈来保存上面的数，对当前数num来说，第一个不能抛弃的数即为num的结果。
    m = {}
    stack = []
    for num in nums2:
        while stack and num > stack[-1]:
            stack.pop()
        m[num] = stack[-1] if stack else -1
        stack.append(num)
    return [m[x] for x in nums1]
```

## Tag
- 单调栈