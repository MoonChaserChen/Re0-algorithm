#### 动态规划
* [从斐波那契数列说起](/src/dp/fbnc.py) 
    1. 从递归到动态规则
        > 斐波那契数列表达式：f(n) = f(n - 1) + f(n-2)，例如我们要计算f(10)，那我们首先应该计算f(9)与，f(8)，但是我们在计算f(9)的时候，
        则又计算了一遍f(8)，因此考虑能否将f(i)的结果保存起来以减少计算量？
    2. 自顶向下动态规划：
        > 计算f(n)时先查看数组当中dp[n]是否已经计算好了，如果计算好了，则直接返回，如果未计算好，则计算并设置dp[n]的值。这种思路比较直接，但仍存在着递归，只是在递归的基础上有了个保存值的操作。
    3. 自底向上动态规划：
        > 从dp[0]到dp[n]均算一遍。简单粗暴，效率还不低。
    4. 自底向上省空间：
        > 在使用自底向上动态规则时，使用了一个数组dp[n]来表示f(i) i∈[0,n]中的每一个值，但如果只需要计算f(n)，实际上只需要两个值即可。

* [三角形路径值问题](/src/dp/triangle.py)

    求三角形从顶到底的一条路径和最大值，路径可以向下或者右下
    ```python
    arr = [[8],
            [5, 19],
            [13, 4, 16],
            [13, 1, 13, 6],
            [18, 15, 8, 16, 3],
            [11, 11, 9, 11, 14, 13],
            [3, 6, 10, 11, 14, 8, 19],
            [17, 20, 0, 13, 7, 13, 5, 20],
            [12, 12, 4, 9, 8, 8, 13, 14, 15],
            [3, 18, 19, 4, 5, 19, 0, 15, 12, 12]]
    ```
    1. 递归
        > 递归表达式f(x，y) = max(f(x + 1, y), f(x + 1, y + 1)) + arr[x][y]，其中x,y为数组下标，f(x,y)表达从坐标(x,y)到最底层的路径最大值，因此求出f(0, 0)即可， 递归结束条件为到达最底层，即x = len(arr) - 1 
    2. 自顶向下动态规划
        > 在以上递归的时候保存下计算的值即可。
    3. 自底向上动态规划
        > 创建一个dp[][]二维数组，其中dp[x][y]表示原数组中arr[x][y]到最底层的最大值。dp数组高层（x较小）依赖于低层（x较大）的值且仅依赖于低一层的值。因此在计算dp[x][y]时，先计算x最大的最后一层，逐层往上计算，最终计算到dp[0][0]即为所求。
    4. 自底向上省空间
        > 因为较低层只会被高一层使用，因此计算后直接将结果放置到原数组，即使用arr[][]代替dp[][]