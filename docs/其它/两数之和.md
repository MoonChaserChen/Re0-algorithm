# 两数之和
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:
```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```
来源：[LeetCode](https://leetcode-cn.com/problems/two-sum)

## 暴力解法
时间复杂度：O(n<sup>2</sup>)
```python
def two_sum(nums, target):
    le = len(nums)
    for i in range(le):
        for j in range(i+1, le):
            if nums[i] + nums[j] == target:
                return i, j
```

## 首尾递进查找
需要一次排序，时间复杂度是 O(nlogn)
```python
def two_sum(nums, target):
    le = len(nums)
    sorted_id = sorted(range(le), key=lambda x: nums[x])
    lo, hi = 0, le - 1
    s = nums[sorted_id[lo]] + nums[sorted_id[hi]]
    while s != target:
        if lo >= hi:
            return None
        if s < target:
            lo += 1
        else:
            hi -= 1
        s = nums[sorted_id[lo]] + nums[sorted_id[hi]]
    return sorted_id[lo], sorted_id[hi]
```

## Hash
遍历并将值存入Hash中
```python
def two_sum(nums, target):
    hm = {}
    for i, x in enumerate(nums):
        rem = target - x
        if rem in hm:
            return  hm[rem], i
        hm[x] = i
```

## nums元素可重复并求出所有
```python
def two_sum(nums, target):
    dic = {}
    re = []
    for x in nums:
        rem = target - x
        if rem in dic:
            for y in dic[rem]:
                re.append([x, rem])
        arr = dic.get(x)
        if arr:
            arr.append(rem)
        else:
            dic[x] = [rem]
    return re
nums0 = [-9, -5, -4, 4, 5, 9, 0, 0, 0, 0]
print(two_sum(nums0, 0)) # [[4, -4], [5, -5], [9, -9], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]
```